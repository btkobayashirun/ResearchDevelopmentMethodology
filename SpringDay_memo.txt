springday web api アクセス制御の最適解

結論 CASE by CASEになる

1、認証と認可について

認証とは？
通信相手が誰なのかを確認する

2、APIの居場所

privateの場合はsecurityはいるのか？
システムのセキュリティホールを除いて
わざわざ、パフォーマンスを犠牲にしてまでhttpsを使う必要があるのか考える必要がある

grobalの場合
言うまでもなくSSlは必須

3、認証の方法
スライド確認
人間社会での行われ方

wahrt you hava
ワンタイムパスワード等

what you know
ぽぴゅらーな方法

認証する、されるが両者機械の場合
秘密鍵等（what you kno）一般的

やりとりする秘密情報クレデンシャル

4、クレデンシャルについて
一度決めたら変更されない、一般的に無期限→静的・無期限　パスワード
上に期限を決める→静的・期限付き　アクセストークン、セッションID
動的→リクエストに署名を付けて送信する　HMACマップ

5、BASIC認証、ダイジェスト認証
ブラウザでは使えない
APIの認証においてHTTPで使う場合については→採用を否定することはできない
OAUTH2も使えなくなる
適切に運用に限り直ちに問題が起こることはない
オススメしない理由、静的無期限な情報が毎回流れる→リスクと言えるほどではないがリスク
SSLも絶対ではない

ダイジェスト認証
BASIC認証を動的なクレデンシャルを扱うように変更したもの
クレデンシャルを送信してもらうためのリクエストと認証のためのリクエストで
認証のたびに二回のリクエストが必要になる
よってWEｂAPIに向かない
ブラウザではいいかもしれない

6、APIキーによる署名
スライド

HMACは自分では実装してはいけない

メッセージとhash、現在時刻など
現在時刻が大きくずれた場合りぷれいアタックではないか

OAUTH1で使われている
HMACの送信方法についてはRFCで定義されていない
AWSでは定義されているがAWSを使うことが限定なので参考にしかならない

7、OAUTH2
oauthは認証をするための仕組みではない
認可をするための仕組みではない
Aがあらかじめ持ってい認可をBに委譲するための仕組み
ユーザが持っている権限をAPIに渡す

静的・期限付きクレデンシャル　アクセストークンをクライアントは受け取る

一般的なAPIアクセス制御
全権を持っているのはフロントエンドのシステム、クライアント
ユーザはクライアントから機能を借りる

OAUTHのアクセス制御
全権を持っているのはユーザ
クライアントはユーザから許可をもらってユーザの代わりに機能を実行する

エンドユーザが全権を持っていることが前提のため
ユーザがこの権限を実行できるかを指定するSCOPEが組み込まれていない

認可の仕組みは自分で実装しなくてはいけない

Spring　Securityの場合　31分から36分

8、openId Conect
WEB APIの認証には関係ない
スライド

まとめ
スライド