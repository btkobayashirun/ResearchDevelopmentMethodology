この資料について
この資料はOAuth2.0について最低限分かるようにまとめたものである。
詳しい情報についてはRFC6749及びRFC6750を参照されたい。

目次
・1, OAuth2.0概要
  1.1, 用語
  1.2, OAuth2.0とは
  1,3, RFCが定める4つの認可グラント
・2, プロトコルと認可グラントのフロー
  2.1  プロトコルのフロー
  2.2, 認可コードのフロー
  2.3, インプリシットのフロー
  2.4, リソースオーナーパスワードクレデンシャルのフロー
  2.5, クライアントクレデンシャルのフロー
・3, 実装を行う上でのポイント

-------------------------------------------------------------------------------------
1.1 用語
・OAuth2.0に関わる用語
   認証             :相手が誰か確認を行うこと
   認可             :リクエストが許可されるかどうか決めること
   クレデンシャル   :認証に使われる秘密情報. 一般的なものではID、パスワードなど
   アクセストークン :OAuth2.0で使用するクレデンシャル. 有効期限が定められている.
   スコープ         :OAuth2.0で使用されるアクセス制御の概念. アクセストークンに含めて送られ、
                     保護されたリソースに対してアクセス権を指定することができる(read only,read and write etc)
   認可グラント     :OAuth2.0で使用されるリソースオーナーの認可を示す概念.
                     クライアントがアクセストークンを取得する際に用いられる. RFCでは4種類定義されている。

・登場するロール (RFC6749 日本語訳より引用)
   リソースオーナー :保護されたリソースへのアクセスを許可するエンティティー. 
                     リソースオーナーが人間の場合, エンドユーザーと呼ばれる. 
   リソースサーバー :保護されたリソースをホストし, アクセストークンを用いた保護されたリソースへのリクエストを受理して
                     レスポンスを返すことのできるサーバー. 
   クライアント     :リソースオーナーの認可を得て, リソースオーナーの代理として保護されたリソースに対するリクエストを
                     行うアプリケーション.
   認可サーバー     :リソースオーナーの認証とリソースオーナーからの認可取得が成功した後, アクセストークンを
                     クライアントに発行するサーバー. 

1.2,OAuth2.0概要

従来の認証方式でサードパーティアプリケーションがサーバ上の保護されたリソースへアクセスするには、ユーザのクレデンシャルから認証を行う必要があった。つまり、サードパーティアプリケーションにユーザのIDやパスワードを共有する必要があった。
この方法では、サードパーティアプリケーションからの情報漏えいのリスクが発生する。
OAuth2.0ではアクセストークンというクレデンシャルを使用することにより、サードパーティアプリケーションとのユーザの
クレデンシャルの共有を行わないようになっている。

OAuth2.0は
「サードパーティーアプリケーションによるHTTPサービスへの限定的なアクセスを可能にする認可フレームワーク」(RFC6749 日本語訳)と定義されている。
Oauth2.0ではサードパーティアプリケーションがサーバ上の保護されたリソースへアクセスする際に、権限を指定することができ、
読み込みのみ、読み込みと書き込み、といった権限の限定をクライアントごとに設定することが可能である。

1.3 RFCが定める4つの認可グラント

OAuth2.0では、アクセストークンを取得する際に、クライアントはリソースサーバーに対して認可グラントを示す必要がある。
RFCによって4つのグラントタイプが用意されており、アプリケーションの構成やアクセスするリソースの状況によって
使い分けることができる。

・認可コード
  認可サーバーがクライアントとリソースオーナーの仲介となって認可コードを発行し、
  認可コードからアクセストークンを取得するグラント。
  基本的にはこのグラントを使用することが推奨される。

・インプリシット
  認可コードを単純化し、JavaScriptの様なスクリプト言語を使用してブラウザ上で実行されるクライアントに最適化されている。
  認可コードを仲介せず、直接アクセストークンを取得することによってクライアントと認可サーバ間での往復回数を減らし
  応答性と効率性を高めている。
  ただし、セキュリティー面でリスクがあるため使用する際はこのことを考慮しなくてはいけない。

・リソースオーナパスワードクレデンシャル
  認可グラントとして、リソースオーナーのクレデンシャルを直接使用し、アクセストークンを得るグラント。
  リソースオーナーのクレデンシャルをクライアントに共有する必要がある点から、リソースオーナーとクライアントに
  高い信頼性があり、他のグラントタイプが使用できない際にのみ使用すべきである。

・クライアントクレデンシャル
  クライアントのクレデンシャルを認可グラントとして使用し、アクセストークンを得るグラント。
  クライントがリソースオーナーである場合に使用することができる。

-------------------------------------------------------------------------------------
2.1 プロトコルのフロー
ここではOAuth2.0でクライアントが保護されたリソースにアクセスするまでのフローを説明する。

  1, クライアントはリソースオーナーに対して認可を要求する
  2, クライアントは認可グラントを受け取る
  3, クライアントは認可サーバーに対して自身を認証し, 認可グラントを提示することで, アクセストークンを要求する
  4, 認可サーバーはクライアントを認証し, 認可グラントの正当性を確認する
     そして認可グラントが正当であれば, アクセストークンを発行する
  5, クライアントはリソースサーバーの保護されたリソースへリクエストを行い, 発行されたアクセストークンにより認証を行う
  6, リソースサーバーはアクセストークンの正当性を確認し, 正当であればリクエストを受け入れる
  
RFCが定める認可グラントは1と2の部分でのフローをそれぞれ定めているが、
インプリシットではクライアントの認証を行わないため、3と4のフローが上記と異なる。

2.2 認可コードのフロー。
  認可コードは前述の通り、まず認可コードを取得し、その認可コードを用いてアクセストークンを取得する。
  
  認可コードを発行するフロー
    1, クライアントはリソースオーナーを認可サーバーへリダイレクトさせる
    2, 認可サーバはリソースオーナーを認証する
    3, リソースオーナーは認可コードと共にクライアントにリダイレクトされ、クライアントは認可コードを取得する。
  
  アクセストークンを発行するフロー
    1, クライアントは認可サーバーに対して認可コードと共にアクセストークン発行のリクエストを送る。
    2, 認可サーバはクライアントの認証を行う。
    3, 認可コードを検証し、正当であった場合はクライアントにアクセストークンを送信する。
  
  認可コードグラントの特徴として
    1, リソースオーナーのクレデンシャルは認可サーバーにのみ共有されクライアントには共有する必要がなくなる。
       (クライアントからリソースオーナーのクレデンシャルの漏洩のリスクがなくなる)
    2, 認可サーバーはクライアントの認証を行う。
       （不正に取得された認可コード使用の防止ができる）
    3, アクセストークンはユーザーエージェントを経由せずにやり取りされる。
       (ユーザーエージェントからアクセストークンが漏洩するリスクがなくなる)
  これらの点が認可コードグラントはセキュリティ面で優れた点であり、推奨される理由である。
